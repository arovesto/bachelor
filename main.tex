\documentclass[a4paper,14pt, openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{extsizes}
\usepackage{url}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    language=go,
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=30mm,
    top=20mm,
    right=15mm,
    bottom=20mm
}
\linespread{1.5}

\title{Масштабируемый движок для нагруженных real-time web приложений на Golang}
\author{Ромащенко Андрей}
\date{2021}
\setlength{\parindent}{2em}

\begin{document}
\maketitle

\chapter*{Аннотация}

Реализация сетевого взаимодействия это основная задача современного программного обеспечения. Во многих случаях, взаимодействие происходит между небольшим количеством серверов, и большим количеством клиентов. Не редко клиентом выступает браузер. Зачастую, приложение не накладывает серьёзных ограничений на скорость взаимодействия между клиентом и сервером. Так же зачастую логика серверного взаимодействия в достаточной мере отделена от логики клиентного взаимодействия. Для этого случая существуют стандартные решения, которые заключаются в том что клиент может запрашивать данные у сервера по мере необходимости, и в этот же момент передавать свои. Однако - существует значительная часть приложений, для которых этот способ не подходит. Например IO-игры, в которых клиентам требуется получать информацию как можно скорее. Так же играм необходимо уметь предсказывать развитие игровых событий до получения свежих данных.В классическом подходе для этого потребовалось бы дублировать логику сервера на клиенте.

В последние несколько лет стало возможно обойти эти сложности, используя технологии \textit{webassembly}  и \textit{websocket}. В этой работе будет рассмотрен подход к написанию движка для подобных проектов, описаны необходимые примитивы и реализован сам движок на языке программирования Go.
\par
\setcounter{page}{2}
\tableofcontents
\clearpage

\chapter{Введение}

\section{Основные понятия}

Введём основные понятия, которые будут использоваться в дальнейшем.

\emph{Сеть} --- несколько компьютеров, соединённых между собой физическими средствами связи, имеющие возможность обмениваться обобщениями при помощи сетевых протоколов.

\emph{Сетевое соединение} --- абстракция над сетевой инфраструктурой и сетевыми протоколами, позволяющая компьютерным программам обмениваться сообщениями.

\emph{Сервер} --- компьютерная программа, подключённая к сети,  обрабатывающая входящие сетевые соединения. В рамках данной работы, рассматриваются сервера реализующие логику приложения, и позволяющие обмениваться информацией соединённым клиентам. 

\emph{Клиент} --- компьютерная программа, при запуске которой инициируется соединение с сервером и начинается обмен сообщениями. В рамках данной работы, клиент запускается в браузере, клиент реализует логику по получению пользовательского ввода и вывода.

\emph{Браузер} --- компьютерная программа, стандартизирующая вид клиентов, реализующая абстракции над вводом и выводом данных пользователя, предоставляющая эти абстракции клиентам.

\emph{Сетевой протокол} --- текстовое описание действий, которые необходимо совершить чтобы реализовать сетевое соединение с заданными свойствами.

\emph{Websocket \cite{websocket}} --- сетевой протокол, реализующий сетевое взаимодействие. Позволяет клиенту и серверу обмениваться сообщениями. Отправитель может отправить в вебсокет сообщение, а получатель его получает, отправителем может выступать как клиент так и сервер. В отличии от классического протокола TCP поддержан в браузере, является одним способом реализовать соединение заключающееся в обмене сообщений.

\emph{Webassembly \cite{webassembly}} --- формат хранения компьютерных программ. Современные браузеры способны исполнять программы в формате webassembly. Для многих языков программирования реализована возможность конвертировать их программный код в webassembly, что позволяет запускать эти программы в браузере.

\emph{Real-time программа} --- в рамках данной работы, программа, имеющая задержку между вводом пользователем данных и выводом реакции на них не более 100 миллисекунд, с допустимыми редкими длительными задержками. (Этот термин значительно отличается от общепринятого определения, заключающегося в том что программа даёт гарантию о времени своего исполнения которая соблюдается во всех случаях). 

\emph{Приложение} --- в рамках данной работы, компьютерная программа, симулирующая взаимодействие объектов. Симуляция происходит на сервере, клиенты могут влиять на состояние связанных с ними объектов. Клиенты получают состояние симуляции и выводят его на экран пользователя.

\section{Цели работы}

\begin{itemize}
  \item Изучить проблемы, возникающие при проектировании сервера для real-time браузерных приложений,
  \item Исследовать проблемы, возникающие при проектирование клиентской части real-time браузерных приложений,
  \item Описать и разработать примитивы, позволяющие создавать real-time приложения,
  \item Реализовать библиотеку для создания конкретных real-time web приложений.
\end{itemize}

\section{Актуальность работы}

Было проведено исследование, которое показало, что на данный момент нет библиотеки, решающей все проблемы возникающие при создании real-time браузерного приложения, существующие аналоги не обладают всем необходимым функционалом, или не обладают необходимой скоростью работы.

\section{План работ}
\emph{Во втором разделе} работы будут описаны проблемы, возникающие в создании серверов и клиентов для real-time web приложений, такие как обработка ввода, обработка коллизий, компенсация сетевой задержки, удаление устаревших данных. 

\emph{В третьем разделе} будут предложены конкретные абстракции, позволяющие обобщить описание приложения, разделить общую логику, которая потребуется любому приложению, от логики специфической для данного приложения. 

\emph{В четвёртом разделе} будет описана реализация простой игры, использующая абстракции описанные в разделе три.


\chapter{Архитектура  real-time браузерных игр}

\section{Сервер}

В этой секции будет описан ряд проблем, с которыми сталкивается разработчик сервера для real-time web приложения. Первая из них это создание протокола взаимодействия.

\subsection{Протокол взаимодействия}

Протокол взаимодействия между клиентом и сервером в любом приложении зачастую строится на использовании существующих протоколов, поверх которых создаётся новый протокол, решающий конкретную задачу. Для приложений в рамках данной работы от протокола зачастую требуется обладать следующими свойствами:

\begin{itemize}
  \item В одном соединении участвует один сервер и несколько клиентов
  \item Клиенты находятся в браузере, что налагает ограничение на возможные сетевые протоколы
  \item Клиенты не общаются напрямую между собой: в браузере существует протокол для взаимодействия клиентов между собой в обход сервера \cite{webrtc} однако зачастую нет выгоды посылать сообщения между клиентами в обход сервера, так как серверу в любом случае нужно пересылать сообщения о не подконтрольных клиентам сущностях отдельно.
  \item Клиентам необходимо иметь возможность запрашивать статические данные у сервера, данные общие для всех клиентов, то есть имеет смысл не получать данные для каждого клиента а дать возможность клиентам самим обращаться к этим данным.
  \item Чаще всего клиент генерирует событие - ввод пользователя, отправляет его серверу. Сам же клиент зачастую дожидается поступления обновлений от сервера о происходящем для синхронизации.
\end{itemize}

Важной особенностью подобного протокола является требования быстродействия. Допустимая задержка ввода данных пользователем может быть порядка 100-500 миллисекунд \cite{latencyArticle}. Допустимы редкие потери объектов, если при этом достигается достаточно большая общая скорость взаимодействия.

В следующей части будет предложен алгоритм, соответствующий указанным требованиям. 

\subsection{Сессии и объекты}

Зачастую в приложении требуется поддержать возможность нескольких одновременно запущенных сессий. Даже если приложение подразумевает соединение всех клиентов на едином пространстве, может потребоваться дополнительная сессия-меню, куда клиенты попадают перед началом игры. Соответственно естественно возникает понятие игровой комнаты, как абстракции над сессией, обладающей некоторыми свойствами:

\begin{itemize}
  \item Комната содержит в себе объекты и занимается их обработкой
  \item В рамках обработки, комната перемещает объекты, проверяет их столкновения, удаляет необходимые, собирает информацию об сущностях, изменивших своё положение, информацию о которых нужно отправить клиентам
  \item Было бы удобно хранить комнату как на клиенте так и на сервере, чтобы иметь возможность запускать симуляцию комнаты на клиенте, не дожидаясь ответа от сервера. 
\end{itemize}

Комната сама по себе не содержит в себе какого-либо состояния, целиком полагаясь на объекты внутри. Однако, для удобства использования, имеет смысл создать некоторое внутреннее состояние, чтобы наперёд заданная функция могла его получать и изменять состояние комнаты соответственно.

Так же у комнаты есть требование по быстродействию, нужно уметь быстро добавлять и удалять элементы, находить элемент по номеру. Соответственно, предполагается хранение элементов комнаты в хештаблице. В таком виде возможно реализовать все действия происходящие с комнатой на каждом шаге симуляции как $O(n) $ от количества объектов в комнате, кроме обработки столкновений, ведь наивный алгоритм проверки столкновений предполагает асимптотику $ O(n^2)$ то есть проверку каждого объекта с каждым. В разделе три мы предложим решение, как оптимизировать данную проблему тем самым увеличив максимально поддерживаемое количество одновременно существующих сущностей.

\subsection{Хранение данных и сборка мусора}

В предыдущей секции мы определили понятие Комнаты, в рамках которой происходит действия. В данном разделе сформулируем что может происходить с комнатами в рамках приложения:

\begin {itemize}
   \item Комната создаётся программным кодом, в момент подключения нового клиента или же в момент исполнения другой комнаты
   \item Во время исполнения комната периодически сохраняет своё состояние в хранилище, чтобы не утерять его при остановке сервера
   \item Комната исполняется, пока есть подключённые к ней клиенты. Как только последний клиент покидает комнату, остаётся несколько вариантов действий
   \item Комната может быть удалена, чтобы не засорять оперативную память компьютера 
   \item Комната может продолжать исполнение, ожидая скорого появления клиентов (актуально для комнат-лобби)
   \item Комната сохраняется в базу данных, с возможностью будущего продолжения работы
   \item Сервер запускает приостановленную комнату когда в неё подключается новый клиент
\end{itemize}

Соответственно возникает необходимость хранить комнаты не только в оперативной памяти но ещё и на диске. В следующем разделе будет подробнее описано подобное хранилище.

\section {Клиент}

В этой секции мы подробнее остановимся на проблемах, возникающих при работе клиента. В рамках нашего сетевого протокола, клиент обрабатывает тот же самый объект комнаты что и сервер, однако он использует методы объектов связанные с отрисовкой и получения ввода (в случае объектов, которыми управляет клиент)

\subsection{Отрисовка происходящего}

Выше мы описывали требования от комнаты как хранилища объектов с точки зрения контейнера, в который могут добавлять и удалять значения, а так же с точки зрения контейнера, разделённого на квадраты-зоны. Сформулируем требования к комнате с точки зрения отрисовки объектов:

\begin{itemize}
  \item Для каждого объекта (подконтрольного клиенту) хотелось бы уметь находить ближайшие объекты, чтобы отобразить только их, и не вызывать функцию отрисовки лишний раз. Отрисовка объекта не попадающего в поле зрения происходит быстро, однако пропадает необходимость итерироваться по всем объектам для отрисовки одного кадра.
  \item Для изображения необходима виртуальная камера, фактически камера должна строить изображение на основе прямоугольника, описывающего ту часть игрового поля которое попадает в объектив. Соответственно этот игровой прямоугольник камера должна привести к размерам прямоугольника - окна браузера.
  \item Необходимо поддерживать некий порядок обода объектов при отрисовке, чтобы избегать проблему "накладывания" одного объекта на другой. Так же хотелось бы иметь возможность хранить элементы некоторыми "слоями", чтобы иметь возможность сперва отрисовать заднюю часть изображения потом переднюю. Таких слоев может быть несколько.
\end{itemize}

Для отрисовки мы во многом полагаемся на встроенный в браузер инструмент - canvas \cite{canvas}. Но для эффективной отрисовки при помощи слоёв требуется поддержка правильного обхода объектов при их отрисовке. Так же необходимо на стороне клиента хранить полученные от сервера текстуры, перед передачей их в canvas для отрисовки.

\subsection{Получение пользовательского ввода}

В начале следующего раздела описывался протокол взаимодействия клиента с сервером, соответственно как только клиент получает объект, которым клиент управляет, клиент начинает запрашивать от пользователя ввод. Здесь опять же, используются встроенные возможности браузера, как-то определение нажатой клавиши или получение положения курсора мыши. 

Каждый управляемый пользователем объект имеет дополнительные возможности, а именно он может создать объект на основании введённых пользователем данных, и по переданному объекту соответствующе изменить своё поведение. Соответственно клиент запрашивает подобные изменения у объекта с некоторой периодичностью и передаёт их на сервер. Локально он их применяет сразу же, чтобы уменьшить ощущаемую задержку ввода. Зачастую события о перемещении принимаются сервером, так что имеет смысл их обработать заранее, не дожидаясь ответа.

\subsection{Компенсация сетевой задержки}

В приложении так или иначе возникает задержка ввода. Задержка ввода складывается из трёх основных компонент:

\begin{itemize}
   \item Сетевая задержка - время между отправкой клиентом данных на сервер и получением ответа от сервера. На эту задержку сложно повлиять, её значения варьируются в широком пределе.(может достигать сотен миллисекунд)
   \item Задержка цикла с логикой - время которое тратится сервером на обновление сущностей - при правильной реализации не зависит от количества сущностей, почти не варьируется, в целом не велика. (порядка десятка миллисекунд)
   \item Задержка отрисовки - время занимаемое на отрисовку нового кадра. При правильной реализации не варьируется, однако его значительно не уменьшить. (порядка десятка миллисекунд)
\end{itemize}

Соответственно, можно увидеть, что много времени занимает именно сеть, данные пересылаются между клиентом и сервером. Однако, действуя в предположении, что мы на клиенте знаем почти то же самое что и сервер, мы можем запустить интерполяцию действий, для этого достаточно запустить обновление объектов на клиенте, а не только на сервере. Когда сервер наконец-то ответит мы просто обновим соответствующий объект. Таким образом можно скомпенсировать часть задержки, однако если задержка будет слишком велика то возможны визуальные "скачки" объектов. 

\chapter {Описание, исполнение, синхронизация приложений}

В этом разделе будут предложены решения проблем, описанных в предыдущем разделе. 

\subsection{Протокол приложения основанный на Websocket}

Во втором разделе в первой части были приведены требования которым должен соответствовать протокол обмена данными между клиентами и сервером. В рамках данной работы предлагается следующий алгоритм:

\begin{itemize}
   \item Сервер по запросам умеет предоставлять файлы, при помощи протокола HTTP, в частности файл \emph{index.html}, внутри которого находится программный код клиента
   \item В момент запуска в браузере клиент инициирует соединение с сервером при помощи протокола Websocket
   \item Сервер при создании нового соединения сперва отправляет клиенту через Websocket информацию о текущих объектах. Эта информация имеет малый объём, а так же постоянно изменяется, что не позволяет раздавать её статически всем клиентам.
    \item Затем сервер выбирает, какой сущностью должен управлять клиент  и отдаёт ему её идентификатор внутри множества текущих объектов.
    \item Сервер принимает от клиента сообщения о пользовательском вводе асинхронно, клиент не ждёт мгновенного ответа от сервера, это снимает нагрузку с сервера.
    \item Сервер исполняет необходимую логику, и если в состоянии каких-то объектов произошли изменения то посылает эти изменения через Websocket всем активным клиентам.
    \item Клиенты сохраняют обновления от сервера в свою локальную копию множества объектов, соответственно не нужно каждый раз посылать информацию обо всех объектах.
    \item Клиент может обращаться к статическим файлам на сервере, таким как текстуры, аудио фрагменты.
\end{itemize}

Таким образом, мы используем преимущества Websocket заключающееся в переиспользовании TCP соединений, что позволяет снизить количество пересылаемых объектов по сети \cite{websocketbook}. 

В тех местах где данные не изменяются с течением времени (например текстуры, которые изменяются только при обновлении приложения) имеет смысл использовать классический подход с HTTP, по скольку в таком случае возможно кеширование данных на стороне браузера и соответственно уменьшение объёма пересылаемых данных \cite{websocketvshttp}.


\subsection{Игровая комната и сущности}

В предыдущем разделе были сформулированы требования по быстродействию для комнаты. Комнату можно легко реализовать наивным способом используя хештаблицу для хранения объектов. 

Можно разделить объекты на категории, хранить отдельно хештаблицы движущихся объектов и хештаблицу объектов которые могут сталкиваться. Это позволяет ускорить цикл обработки который занимает большую часть времени работы комнаты.

Так же в предыдущем разделе была сформулирована проблема рассчета коллизий. В игре необходимо уметь быстро находить объекты, физически находящиеся рядом с заданным, делать это быстрее чем за $O(n)$. Для этого самым простым способом будет использовать систему квадратов, каждый из которых имеет фиксированные размеры. В таком случае, зная местоположение можно понять в каком квадрате он находится (просто разделив координаты объекта на размеры квадрата), затем высчитать функцию столкновения только с теми объектами, которые находятся в тех же квадратах что и данный. Важно хранить объект во всех квадратах, куда он попадает, иначе можно пропустить столкновения на границе квадратов.

Цикл обновления комнаты выглядит так:
\begin {itemize}
  \item Комната обновляет все объекты которые могут передвигаться
  \item Для этого комната передаёт время, произошедшее в симулируемом мире с прошлого вызова функции
  \item Комната рассчитывает столкновения объектов, которые могут сталкиваться. Для этого использует дополнительную структуру данных на объектах
  \item В случае сервера, комната обрабатывает входящие игровые события и посылает исходящие 
  \item Цикл обновления запускается раз в несколько миллисекунд чтобы не загружать процессор
\end {itemize}

В момент обработки коллизий игра не рассчитывает явно, столкнулись ли объекты или нет, каждый объект сам проверяет, столкнулся ли он с переданным объектом или нет. Это позволяет реализовывать более гибкие системы, однако функция проверки столкновений так же реализована. На данный момент, каждый объект может иметь вид объединения ориентированных прямоугольников и кругов. Соответственно, при рассчитывании столкновений двух объектов проверяются пересекаются ли данные множества, а так же предоставляется вектор, двигаясь по которому объекты выйдут из столкновения. В таком виде остаётся опасность туннелирования, однако для этого объект должен двигаться с очень большой скоростью, чтобы "проскочить" другой объект.

\subsection{Событие}

В предыдущих разделах описывался механизм создания сетевого протокола. В рамках него, несколько клиентов общаются с сервером. В этой секции будет описано какими именно сообщениями обменивается клиент и сервер.

Все сообщения структурированы и имеют вид "игровых событий". Игровое событие это объект, у которого есть тип а так же идентификатор отправителя. У события так же есть дополнительное поле, которое используется в зависимости от типа. Существует несколько заранее заданных типов событий, такие как получение пользовательского ввода, обновление игровой сущности, событие в котором описана вся комната целиком, событие удаление объекта, событие окончание симуляции для данного клиента.

События от клиентов попадая на сервер выстраиваются в очередь событий, события попадающие к клиенту применяются сразу же. Заданные типы событий обрабатываются сразу же, а для пользовательских типов событий вызывается соответствующий обработчик, если такой найден. 

Помимо клиента и сервера события могут быть сгенерированы объектами во время их обновления, для этого в функцию обновления комната передаёт объект для передачи сообщений.

События, так же, имеют возможность преобразовываться в json и наоборот, таким образом они передаются по сети. Событие может содержать внутри себя игровой объект, по этому от объекта требуется возможность преобразовать себя в набор байт, и быть впоследствии распакованным из набора байт.

\subsection{Графический контекст}

Для взаимодействия с предоставляемыми браузером возможностями отрисовки, написана прослойка, так называемый графический контекст. Графический контекст это специальный объект, создающийся во время создания клиента. Формат Webassembly позволяет запускать программу на произвольном языке программирования из браузера, однако помимо этого он позволяет обращаться к возможностям браузера используя вызовы Javascript. Соответственно контекст создаёт внутри себя контекст из canvas, и каждый кадр передаёт туда свежее изображение. Однако с целью оптимизации, чтобы ликвидировать затраты на вызовы javascript изображение создаётся целиком на стороне Go, и зачем направляется в javascript. 

Помимо работы с canvas, внутри графического контекста поддержана возможность создавать html элементы в качестве отрисованного результата для объекта. Это позволяет создавать поля ввода используя средства html вместо создания нового объекта. 

Графический контекст предоставляет интерфейс, позволяющий отрисовать либо произвольную геометрическую форму либо заданную текстуру в заданной точке. Когда все объекты отрисованы, текстура отправляется в canvas.

Графический контекст требует, чтоб сперва были отрисованы объекты, которые находятся на заднем плане, а затем объекты на переднем плане. Эта возможность нужна не всегда, если объект не поддерживает слои, то он рисуется всегда на самом переднем плане. Для реализации этой возможности, в объекте Комнате поддержана ещё одна структура данных, массив хештаблиц, каждый массив обозначает слой со своим номером, от самых дальних до самых ближних. В хештаблицах хранятся указатели на объекты. Это позволяет быстро обходить все объекты в правильном порядке, а так же быстро добавлять и удалять объекты.

Так же графический контекст поддерживает "виртуальную камеру"  - некоторый глобальный координатный сдвиг, используемый при выводе объектов отрисовывать их относительно какой-то точки в игровом пространстве. 


\subsection{Хранилище данных комнат}

Во втором разделе описывалась проблема хранения комнат, пустую комнату нужно удалять или хранить или продолжать выполнять в зависимости от ситуации. Для этого пользователю передано хранилище данных комнат. Когда комнату покидает последний клиент вызывается либо переданная пользователем функция, либо комната помечается в хранилище как удалённая. Хранилище представляет собой объект, с хештаблицей, где хранятся активные исполняемые комнаты и подключением к базе данных. По скольку комнаты сами по себе представляют сериализуемый объект, они могут храниться в любом возможном хранилище. Go предоставляет абстракцию над базами данных, так что хранилище можно выбирать самостоятельно.

Так же хранилище предоставляет возможность перемещать сущность из комнаты в комнату. При этом в одном режиме сущность просто перемещается, во втором режиме данному подключённому клиенту назначается сущность с
переданным номером в новой комнате.

При создании, хранилище запускает процесс, который раз в некоторое время (раз в несколько минут) сохраняет все активные не динамические комнаты в базу данных, на случай поломок. На данный момент, нет возможности переподключиться к уже запущенной комнате (движок никак не использует cookie браузера), однако упавшая комната будет поднята когда к ней кто-то обратится.

Вместе с комнатой хранится название сервера, исполняющего её (если комната исполняется). При перенаправлении игрока в комнату, находящуюся на другом сервере, клиенту сперва направляется событие с требованием подключиться к новому серверу.

При выходе последнего игрока из комнаты комната перестаёт исполняться, и в зависимости от настроек удаляется или сохраняется в базе данных.

\subsection{Работа с геометрией}

Для работы с геометрией, предоставляется несколько готовых примитивов, такие как окружность, ориентированный прямоугольник, вектор. Для окружностей и прямоугольников поддержаны функции проверки столкновения, для прямоугольников поддеражаны функции "выталкивания" позволяющие объектам касаться друг друга а не проходить насквозь. Так же поддержаны функции для работы с векторами. 

\subsection{Выбор технологий}

В качестве языка разработки был выбран Go, так как он обладает многими встроенными возможностями, упрощающими реализацию описанного алгоритма, такими как поддержку взаимодействия с базами данных при помощи обобщённого интерфейса, что позволяет абстрагироваться от конкретной базы данных, а так же возможности из коробки запаковывать и распаковывать объекты в бинарные данные при помощи json. Так же в Go поддержан сборщик мусора, имеющий стабильное время работы, то есть не будет "скачков" в скорости работы приложения. 

В качестве языка разработки для клиента так же используется Go, собирающийся для работы в браузере при помощи Webassembly. Это позволяет реализовывать клиент и сервер на одном языке, что позволяет реализовать логику один раз для клиента и сервера.

В качестве протокола данных для обмена сообщениями используется JSON а не protobuf, потому что размер пересылаемых сообщений ожидается небольшим, одно сообщение должно попадать в один пакет данных, тем самым уменьшение объёма пересылаемых данных не даст значительного прироста скорости. Однако, json позволяет более легко создавать новые типы пересылаемых данных.

В качестве протокола взаимодействия был выбран Websocket потому что он позволяет поддерживать одно долгоиграющее соединение, то есть фактически работает быстрее чем постоянный вызов HTTP запросов.

В качестве базы данных был выбран Postgres, так как он имеет хорошую скорость работы, а так же отлично поддержан в Go. 


\chapter{Реализация игры с помощью движка}

В этом разделе будут описан пример приложения, которое можно создать при помощи данного фреймворка. Приложение носит демонстрационный характер. Приложение основано на нескольких комнатах. В начале игрок попадает в комнату - лобби. В этот момент игрок управляет игровым персонажем, который перемещается получая ввод данных с клавиатуры, а так же обладает анимацией перемещения. В комнате лобби находятся изначально все игроки, те игроки которые хотят попасть собственно в игру собираются в специальной точке и затем нажимают специальную кнопку. Для игроков решивших сыграть вместе создаётся отдельная комната с игрой которая исполняется до завершения игры, затем удаляется. В зависимости от результата, игроки видят либо информацию о победе либо о поражении. 

Соответственно, в этом приложении существует три наперёд заданные постоянно исполняющиеся, восстанавливающиеся из базы данных при падении комнаты: комната-лобби, комната с победным сообщением, комната с сообщением о проигрыше. Так же - создаются динамические комнаты, они не сохранятся в базу данных при падении.  

\subsection{Создание своих сущностей}

Каждая сущность должна удовлетворять интерфейсу, чтобы быть принятой игрой:
\lstinputlisting[language=Go,
caption=Интерфейс сущности]{element.go}

При помощи этого интерфейса можно создать статическую сущность, она будет находиться всегда в одном месте, она не будет участвовать в взаимодействиях, ею нельзя будет управлять и она никак не обновляется. Такая сущность полезна для создания статических переменных окружения, например задника или картинки:
\lstinputlisting[language=Go,
caption=Реализация статического окружения]{background.go}

Этот обьект используется в лобби и других статичных комнатах для создания задника при помощи текстуры.

Если пользователь хочет, чтобы реализованные объекты могли обновляться, участвовать в коллизии, быть управляемым игроком, то ему следует реализовать следующие методы:
\lstinputlisting[language=Go,
caption=Реализация статического окружения]{interfaces.go}

Не обязательно реализовывать все три, например для комнат с сообщением о победе и проигрыше используется объект, реализующий интерфейс игрока, чтобы клиент мог взять управление, но при этом не делающий ничего, игрок просто дожидается появление нового игрока, затем игра переправляет обоих игроков в "игровую" комнату.

Так же полезно иметь объект, который обновляется но не выводит я на экран, например объект - игровой контроллер который отслеживает состояние игры, добавляет врагов или выдаёт аптечку игрокам. Сюда же можно отнести объект "триггер" - который собирает игроков и перемещает их в новую игровую комнату в момент начала игры.

Для реализации объекта, управляемого игроком требуется реализовать дополнительные методы, используемые для получения пользовательского ввода и отправки его на сервер. Для получения пользовательского ввода используются возможности javascript - его функции вызываются из Go. 

Иногда объектам нужно не только изменять своё внутреннее состояние но и взаимодействовать с другими объектами. Для этого используется функция  \textit{Collide}, внутри которой обрабатываются столкновения. Для этого могут быть функции из внутренней библиотеки для работы с геометрией - функции для проверки пересечений геометрических фигур.

Так же каждый объект может получать доступ к состоянию комнаты через объект  \textit{EventProcessor}. Игрок имеет возможность получить доступ к объектам, создать или удалить объект (эта возможность активно используется в обьекте - контроллере игры). При этом здесь проявляется различие выполнение кода на клиенте и на сервере, все вызовы создания нового объекта от клиента игнорируются, здесь всегда отдаётся предпочтение серверу, чтобы избежать проблем синхронизации клиента и сервера. 

У каждой сущности должен быть целочисленный тип а так же идентификатор. Идентификатор используется игрой для общения между объектами, тип используется для правильного декодирования объекта при пересылке по сети. Все созданные типы объектов должны быть сохранены в глобальной таблице типов, иначе клиент или сервер не смогут с ними работать.

\subsection{Расширение возможностей комнаты}

Всё что происходит внутри комнаты реализуется созданием для этого специального, контролирующего объекта, который взаимодействует с комнатой. 

Сама по себе комната не является отдельным интерфейсом, а является объектом, который нельзя изменять под себя. Объект- комната отвечает за общение с клиентами, хранение и обработку объектов. Создатель игры может настроить комнату через передаваемые параметры.

Для каждой комнаты необходимо уметь выбирать игровой объект, которым будет управлять подключающийся клиент. Для этого используется игровой объект со специальном интерфейсом, или, в его отсутствие, заранее заданная функция, которой на вход передаётся таблица потенциально управляемых сущностней а так же таблица уже занятых сущностей.  

Также создателю игры необходимо будет реализовать функцию выбора комнаты, куда поместить подключающегося игрока. В эту функцию передаётся хранилище комнат. и либо может использоваться комната-лобби с заранее известным идентификатором, либо может создаваться новая комната на лету. Для демо-игры всегда передаётся комната с известным идентификатором то есть комната-лобби, однако легко можно было бы модифицировать это поведение, например, направлять игроков в новую комнату-лобби если старая комната переполнена. 

Через параметры комнаты можно настраивать поведение при покидании последним игроком комнаты, по умолчанию в данном случае комната будет сразу же удалена. 

Через параметры комнаты можно указать, требуется ли симулировать комнату на клиенте, а так же скорость анимации на клиенте и скорость обновления клиентов на сервере.

Параметры комнаты сохраняются вместе с ней в базе данных.

Объекты могут быть подписаны на игровые события, для этого у объекта должны быть реализованы методы получения списка интересующих событий, а так же метод, вызывающийся при получении события. Доставкой событий занимается комната. Есть возможность создавать новые виды событий. 

\subsection{Сборка и запуск}

Для работы игры необходимо отдельно скомпилировать клиент и сервер. 

Для клиента есть готовая написанная функция игрового цикла, для работы достаточно импортировать её и запустить. Но для корректной работы необходимо чтобы клиент импортировал себе код  добавленных игровых объектов. Клиент собирается в режиме \textit{js wasm} то есть в webassembley с возможностью вызова функций javascript. Собранный таким способом бинарный файл необходимо переместить в папку со статическими игровыми ресурсами.

Для сервера необходимо так же импортировать код готового сервера, передать ему необходимые функции для работы описанные выше и запустить его. Клиент собирается в стандартный бинарный файл, под ту платформу которая используется.

Так же для работы серверу необходимо иметь папку со статическими ресурсами, такими как стартовая страница \textit{index.html}, javascript библиотека для работы go в браузере, собственно собранный выше клиент, а так же папка с дополнительными ресурсами - текстурами и аудиофайлами.

В репозитории проекта находятся скрипты для сборки и запуска демо-игры под Linux и Windows. 


\chapter{Выводы}

В данной работе был исследован ряд проблем связанных с разработкой real-time web приложений, сложности возникающие при создании сервера, клиента, предпочтительные протоколы и алгоритмы. Сложности обработки столкновений и хранения объектов. Результатом работы стал движок, который предоставляет пользователю возможность описать объекты, сконцентрировавшись только на их поведенческой логике. Движок предоставляет сервер, к которому могут подключаться клиенты из браузера. Благодаря системе абстракций "Комната" есть возможность обрабатывать несколько игр параллельно, есть возможность сохранить состояние приложения и продолжить его исполнение. Полученный исходный код выложен на GitHub.

Однако исследование не завершено, главным образом из за возможных оптимизаций существующего кода. Главное необходимое улучшение - добавление возможности переподключения к внезапно остановленной комнате. Так же движку пока что не хватает геометрических возможностей, отсутствую геометрические формы отличные от сферы и ориентированного прямоугольника. Так же отсутствует встроенная физическая модель. которая однако требуется в большинстве проектов. Так же нет готовой поддержки анимаций - что требуется ещё чаще. Сюда же можно отнести эффекты постобработки. Всё это может быть постепенно добавлено в существующую кодовую базу без существенных её изменений.


\bibliographystyle{unsrt}
\bibliography{references}

\end{document}