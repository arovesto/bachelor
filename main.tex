\documentclass[a4paper,14pt, openany]{book}
\pagestyle{plain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{extsizes}
\usepackage{url}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{tempora}
\usepackage{amsmath}
\usepackage[nottoc,notlot,notlof,numbib]{tocbibind}
\usepackage{natbib}
\usepackage{indentfirst}
\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    frame=single,
    aboveskip=5mm,
    belowskip=5mm,
    backgroundcolor=\color{backcolour},   
    language=scala,
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\small\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=7pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
  
\geometry{
    a4paper,
    left=20mm,
    top=20mm,
    right=20mm,
    bottom=20mm
}
\linespread{1.5}

\title{Масштабируемый движок для нагруженных real-time web приложений на Golang}
\author{Ромащенко Андрей}
\date{2021}
\setlength{\parindent}{2em}

\begin{document}
\maketitle

\chapter*{Аннотация}

Реализация сетевого взаимодействия это основная задача современного програмного обеспечения. Во многих случаях, взаимодействие происходит между небольшим количеством серверов, и большим количеством клиентов. Не редко клиентом выступает браузер. Зачастую, приложение не накладывает серьезных ограничений на скорость взаимодействия между клиентом и сервером. Так же зачастую логика серверного взаимодействия в достаточной мере отделена от логики клиентного взаимодействия. Для этого случая существуют стандартные решения, которые заключатся в том что клиент может запрашивать данные у сервера по мере необходимости, и в этот же момент передавать свои. Однако - существует значительная часть приложений, для которых этот способ не подходит. Например IO-игры, в которых клиентам требуется получать информацию как можно скорее. Так же играм необходимо уметь предсказывать развитие игровых событий до получения свежих данных.В класическом подходе для этого потребовалось бы дублировать логику сервера на клиенте.

В последние несколько лет стало возможно обойти эти сложности, используя технологии \textit{webassembley}  и \textit{websocket}. В этой работе будет рассмотрен подход к написанию движка для подобных проектов, описаны необходимые примитивы и реализован сам движок на языке программирования Go.
\par
\setcounter{page}{1}
\tableofcontents
\clearpage



\chapter{Введение}

\section{Основные понятия}

Введём основные понятия, которые будут использоваться в дальнейшем.

\emph{Сеть} --- несколько компьютеров, соединённых между собой физическими средствами связи, имеющие возможность обмениваться сообщенями при помощи сетевых протоколов.

\emph{Сетевое соединение} --- абстракция над сетевой инфраструктурой и сетевыми протоколами, позволяющая компьютерным программам обмениваться сообщениями.

\emph{Сервер} --- компьютерная программа, подключенная к сети,  обрабатывающая входящие сетевые соединения. В рамках данной работы, рассматриваются сервера реализующие логику приложения, и позволяющие обмениваться информацией соединённым клиентам. 

\emph{Клиент} --- компьютерная программа, при запуске которой инициируется соединение с сервером и начинается обмен сообщениями. В рамках данной работы, клиент запускается в браузере, клиент реализует логику по получению пользовательского ввода и вывода.

\emph{Браузер} --- компьютерная программа, стандартизирующая вид клиентов, реализующая абстракции над вводом и выводом данных пользователя, предоставляющая эти абстракции клиентам.

\emph{Сетевой протокол} --- текстовое описание действий, которые необходимо совершить чтобы реализовать сетевое соединение с заданными свойствами.

\emph{WebSocket \cite{websocket}} --- сетевой протокол, реализующий сетевое взаимодействие. Позволяет клиенту и серверу обмениваться сообщениями. Отправитель может отправить в вебсокет сообщение, а получатель его получает, отпавителем может выступать как клиент так и сервер. В отличии от классического протокола TCP поддержан в браузере, является одним способом реализовать соединение заключающееся в обмене сообщений.

\emph{Webassembley \cite{webassembley}} --- формат хранения компьютерных программ. Современные браузеры способны исполнять программы в формате webassembley. Для многих языков программирования реилизована возможность сконвертировать их програмный код в webassembley, что позволяет запускать эти программы в браузере.

\emph{Real-time программа} --- в рамках данной работы, программа, имеющая задержку между вводом пользователем данных и выводом реакции на них не более 100 миллисекунд, с допустимыми редкими длительными задержками. (Этот термин значительно отличается от общепринятого определения, заключающегося в том что программа дает гарантию о времени своего исполнения которая соблюдается во всех случаях). 

\emph{Приложение} --- в рамках данной работы, компьютерная программа, симмулирующая взаимодействие обьектов. Симмуляция происходит на сервере, клиенты могут влиять на состояние связанных с ними обьектов. Клиенты получают состояние симуляции и выводят его на экран пользователя.

\section{Цели работы}

\begin{itemize}
  \item Изучить проблемы, возникающие при проектировании сервера для real-time браузерных приложений,
  \item Исследовать проблемы, возникающие при проектирование клиентской части real-time браузерных приложений,
  \item Описать и разработать примитивы, позволяющие создавать real-time приложения,
  \item Реализовать библиотеку длясоздания конкретных real-time web приложений.
\end{itemize}

\section{План работ}
\emph{Во втором разделе} работы будут описаны проблемы, возникающие в создании серверов и клиентов для real-time web приложений, такие как обработка ввода, обработка коллизий, компенсация сетевой задержки, удаление устаревших данных. 

\emph{В третьем разделе} будут предложены конкретные абстракции, позволяющие обобщить описание приложения, разделить общую логику, которая потребуется любому приложению, от логики специфической для данного приложения. 

\emph{В четвертом разделе} будет описана реализация простой игры, использующая абстракции описанные в разделе три.


\chapter{Архитектура  real-time браузерных игр}

\section{Сервер}

В этой секции будет описан ряд проблем, с которыми сталкивается разработчик сервера для real-time web приложения. Первая из них это создание протокола взаимодействия.

\subsection{Протокол взаимодействия}

Протокол взаимодействия между клиентом и сервером в любом приложении зачастую строится на использовании существующих протоколов, поверх которых создаётся новый протокол, решающий конкретную задачу. Для приложений в рамках данной работы от протокола зачастую требуется обладать следующими свойствами:

\begin{itemize}
  \item В одном соединении участвует один сервер и несколько клиентов
  \item Клиенты находятся в браузере, что налагает ограничение на возможные сетевые протоколы
  \item Клиенты не общаются напрямую между собой: в браузере существует протокол для взаимодействия клиентов между собой в обход сервера \cite{webrtc} однако зачастую нет выгоды посылать сообщения между клиентами в обход сервера, так как серверу в любом случае нужно пересылать сообщения о неподконтрольных игрокам сущностях отдельно.
  \item Клиентам необходимо иметь возможность запрашивать статические данные у сервера, данные общие для всех клиентов, то есть имеет смысл не получать данные для каждого игрока а дать возможность игрокам самим обращаться к этим данным.
  \item Чаще всего клиент генерирует событие - ввод пользователя, отправляет его серверу. Сам же клиент зачастую дожидается поступления обновлений от сервера о происходящем для синхронизации.
\end{itemize}

Важной особенностью подобного протокола является требования быстродействия. Допустимая задержка ввода данных пользователем может быть порядка 100-500 миллисекунд \cite{latencyArticle}. Допустимы редкие потери обьектов, если при этом достигается достаточно большая общая скорость взаимодействия.

В следующей части будет предложен алгоритм, соответствующий указанным требованиям. 

\subsection{Сессии и обьекты}

Зачастую в приложении требуется поддержать возможность нескольких одновременно запущенных сессий. Даже если приложение подразумевает соединение всех игроков на едином пространстве, может потребоваться дополнительная сессия-меню, куда игроки попадают перед началом игры. Соответственно естественно возникает понятие игровой комнаты, как абстракции над игровой сессией, обладающей некоторыми свойствами:

\begin{itemize}
  \item Комната содержит в себе обьекты и занимается их обработкой
  \item В рамках обработки, комната перемещает обьекты, проверяет их столкновения, удаляет необходимые, собирает информацию об сущностях, изменивших свое положение, информацию о которых нужно отпавить игрокам
  \item Было бы удобно хранить комнату как на клиенте так и на сервере, чтобы иметь возможность запускать симуляцию комнаты на клиенте, не дожидаясь ответа от сервера. 
\end{itemize}

Комната сама по себе не содержит в себе какого-либо состояния, целиком полагаясь на обьекты внутри. Однако, для удобства использования, имеет смысл создать некоторое внутреннее состояние, чтобы наперёд заданная функция могла его получать и изменять состояние комнаты соответственно.

Так же у комнаты есть требование по быстродействию, нужно уметь быстро добавлять и удалять элементы, находить элемент по номеру. Соответственно, предполагается хранение элементов комнаты в хештаблице. В таком виде возможно реализовать все действия происходящие с комнатой на каждом шаге симуляции как $O(n) $ от количества обьектов в комнате, кроме обработки столкновений, ведь наивный алгоритм проверки столкновений предполагает ассимптотику $ O(n^2)$ то есть проверку каждого обьекта с каждым. В разделе три мы предложим решение, как оптимизировать данную проблему тем самым увеличив максимально поддерживаемое количество одновременно существующих сущностей.

\subsection{Хранение данных и сборка мусора}

В предыдущей секции мы определили понятие Комнаты, в рамках которой происходит действия. В данном разделе сформулируем что может происходить с комнатами в рамках приложения:

\begin {itemize}
   \item Комната создается програмным кодом, в момент подключения нового игрока или же в момент исполнения другой комнаты
   \item Во время исполнения комната периодически сохраняет свое состояние в хранилище, чтобы не утерять его при остановке сервера
   \item Комната исполяется, пока есть подключенные к ней клиенты. Как только последний клиент покидает комнату, остается несколько вариантов действий
   \item Комната может быть удалена, чтобы не засорять оперативую память компьютера 
   \item Комната может продолжать исполнение, ожидая скорого появляения игроков (актуально для комнат-лобби)
   \item Комната сохраняется в базу данных, с возможностью будущего продолжения работы
   \item Сервер запускает приостановленную комнату когда в неё подключается новый ирок
\end{itemize}

Соответственно возникает необходимость хранить комнаты не только в оперативной памяти но ещё и на диске. В следующем разделе будет подробнее описано подобное хранилище.

\section {Клиент}

В этой секции мы подробнее остановимся на проблемах, возникающих при работе клиента. В рамках нашего сетевого протокола, клиент обрабатывает тот же самый обьект комнаты что и сервер, однако он использует методы обьектов связанные с отрисовкой и получения ввода (в случае обьектов, которыми управляет клиент)

\subsection{Отрисовка происходящего}

Выше мы описывали требования от комнаты как хранилища обьектов с точки зрения контейнера, в который могут добавлять и удалять значения, а так же с точки зрения контейнера, разделенного на квадраты-зоны. Сформулируем требования к комнате с точки зрения отрисовки обьектов:

\begin{itemize}
  \item Для каждого обьекта (подконтрольного клиенту) хотелось бы уметь находить близлижайшие обьекты, чтобы отобразить только их, и не вызывать функцию отрисовки лишний раз. Отрисовка обьекта не попадающего в поле зрения происходит быстро, однако пропадает необходимость итерироваться по всем обьектам для отрисовки одного кадра.
  \item Для изображения необходима виртуальная камера, фактически камера должна строить изображение на основе прямоугольника, описывающего ту часть игрового поля которое попадает в обьектив. Соответственно этот игровой прямоугольник камера должна привести к размерам прямоугольника - окна браузера.
  \item Необходимо поддерживать некий порядок обода обьектов при отрисовке, чтобы избегать проблему "накладывания" одного обьекта на другой. Так же хотелось бы иметь возможность хранить элементы некоторыми "слоями", чтобы иметь возможность сперва отрисовать заднюю часть изображения потом переднюю. Таких слоев может быть несколько.
\end{itemize}

Для отрисовки мы во многом полагаемся на встроенный в браузер инструмент - canvas \cite{canvas}. Но для эффективной отрисовки при помощи слоёв требуется поддержка правильного обхода обьектов при их отрисовке. Так же необходимо на стороне клиента хранить полученные от сервера текстуры, перед передачей их в canvas для отрисовки.

\subsection{Получение пользовательского ввода}

В начале следующего раздела описывался протокол взаимодействия клиента с сервером, соответственно как только клиент получает обьект, которым клиент управляет, клиент начинает запрашивать от пользователя ввод. Здесь опять же, используются встроенные возможности браузера, как-то определение нажатой клавиши или получение положения курсора мыши. 

Каждый управляемый пользователем обьект имеет дополнительные возможности, а именно он может создать обьект на основании введеных пользователем данных, и по переданному обьекту соответствующе изменить свое поведение. Соответственно клиент запрашивает подобные изменения у обьекта с некоторой периодичностью и передает их на сервер. Локально он их применяет сразу же, чтобы уменьшить ощущаемую задержку ввода. Зачастую события о перемещении прнимаются сервером, так что имеет смысл их обработать заранее, не дожидаясь ответа.

\subsection{Компенсация сетевой задержки}

В приложении так или иначе возникает задержка ввода. Задержка ввода складывается из трех основных компонент:

\begin{itemize}
   \item Сетевая задержка - время между отправкой клиентом данных на сервер и получением ответа от сервера. На эту задержку сложно повлиять, её значения варьируются в широком пределе.(может достигать сотен миллисекунд)
   \item Задержка цикла с логикой - время которое тратися сервером на обновление сущностей - при правильной реализации не зависит от количества сущностей, почти не варьируется, в целом не велика. (порядка десятка миллисекунд)
   \item Задержка отрисовки - время занимаемое на отрисовку нового кадра. При правильной реализации не варьируется, однако его значительно не уменьшить. (порядка десятка миллисекунд)
\end{itemize}

Соответственно, можно увидеть, что много времени занимает именно сеть, данные пересылаются между клиентом и сервером. Однако, действуя в предположении, что мы на клиенте знаем почти то же самое что и сервер, мы можем запустить интерполяцию действий, для этого достаточно запустить обновление обьектов на клиенте, а не только на сервере. Когда сервер наконец-то ответит мы просто обновим соответствующий обьект. Таким образом можно скомпенсировать часть задержки, однако если задержка будет слишком велика то возможны визуальные "скачки" обьектов. 

\chapter {Описание, исполнение, синхронизация приложений}



\subsection{Протокол приложения основанный на WebSocket}

Во втором разделе в первой части были приведены требования которым долежн соответствовать протокол обмена данными между клиентами и сервером. В рамках данной работы предлагается следующий алгоритм:

\begin{itemize}
   \item Сервер по запросам умеет предоставлять файлы, при помощи протокола HTTP, в частности файл \emph{index.html}, внутри которого находится програмный код клиента
   \item В момент запуска в браузере клиент инициирует соединение с сервером при помощи протокола WebSocket
   \item Сервер при создании нового соединения сперва отправляет клиенту через WebSocket информацию о текущих обьектах. Эта информация имеет малый обьем, а так же постоянно изменяется, что не позволяет раздавать её статически всем игрокам.
    \item Затем сервер выбирает, какой сущностью должен управлять игрок и отдает ему её идентификатор внутри множества текущих обьектов.
    \item Сервер принимает от клиента сообщения о пользовательском вводе ассинхронно, клиент не ждет мгновенного ответа от сервера, это снимает нагрузку с сервера.
    \item Сервер исполняет необходимую логику, и если в состоянии каких-то обьектов произошли изменения то посылает эти изменения через WebSocket всем активным клиентам.
    \item Клиенты сохраняют обновления от сервера в свою локальную копию множества обьектов, соответственно не нужно каждый раз посылать информацию обо всех обьектах.
    \item Клиент может обращаться к статическим файлам на сервере, таким как текстуры, аудиофрагменты.
\end{itemize}

Таким образом, мы используем преимущества WebSocket заключающееся в переиспользовании tcp соединений, что позовляет снизить количество пересылаемых обьектов по сети \cite{websocketbook}. 

В тех местах где данные не изменяются с течением времени (например текстуры, которые изменяются только при обновлении приложения) имеет смысл использовать классический подход с HTTP, по скольку в таком случае возможно кеширование данных на стороне браузера и соответственно уменьшение обьема пересылемых данных \cite{websocketvshttp}.


\subsection{Игровая комната и сущности}

В предыдущем разделе были сформулированы требования по быстродействию для комнаты. Комнату можно легко реализовать наивным способом используя хештаблицу для хранения обьектов. 

Можно разделить обьекты на категории, хранить отдельно хештаблицы движущихся обьектов и хештаблицу обьектов которые могут сталкиваться. Это позволяет ускорить цикл обработки который занимает большую часть времени работы комнаты.

Так же в предыдущем разделе была сформулирована проблема рассчета коллизий. В игре необходимо уметь быстро находить обьекты, физически находящиеся рядом с заданным, делать это быстрее счем за $O(n)$. Для этого самым простым способом будет использовать систему квадратов, каждый из которых имеет фиксированные размеры. В таком случае, зная местоположение можно понять в каком квадрате он находится (просто разделив координаты обьекта на размеры квадрата), затем высчитать функцию столкновения только с теим обьектами, которые находятся в тех же квадратах что и данный. Важно хранить обьект во всех квадратах, куда он попадает, иначе можно пропустить столкновения на границе квадратов.

Цикл обновления комнаты выглядит так:
\begin {itemize}
  \item Комната обновляет все обьекты которые могут передвигаться
  \item Для этого комната передает время, произошедшее в симулируемом мире с прошлого вызова функции
  \item Комната рассчитывает столкновения обьектов, которые могут сталкиваться. Для этого использует дополнительную структуру данных на обьектах
  \item В случае сервера, комната обрабатывает входящие игровые события и посылает исходящие 
  \item Цикл обновления запускается раз в несколько миллисекунд чтобы не загружать процессор
\end {itemize}

В момент обработки коллизий игра не рассчитывает явно, столкнулись ли обьекты или нет, каждый обьект сам проверяет, столкнулся ли он с переданным обьектом или нет. Это позволяет реализовывать более гибкие системы, однако функция проверки столкновений так же реализована. На данный момент, каждый обьект может иметь вид обьединения ориентированных прямоугольников и кругов. Соответственно, при рассчитывании столкновений двух обьектов проверяются пересекаются ли данные множества, а так же предоставляется вектор, двигаясь по которому обьекты выйдут из столкновения. В таком виде остается опасность туннелирования, однако для этого обьект должен двигаться с очень большой скоростью, чтобы "проскочить" другой обьект.

\subsection{Событие}

В предыдущих разделах описывался механизм создания сетевого протокола. В рамках него, несколько клиентов общаются с сервером. В этой секции будет описано какими именно сообщениями обменивается клиент и сервер.

Все сообщения структурированы и имеют вид "игровых событий". Игровое событие это обьект, у которого есть тип а так же идентификатор отправителя. У события так же есть дополнительное поле, которое используется в зависимости от типа. Существует несколько заранее заданных типов событий, такие как получение пользовательского ввода, обновление игровой сущности, событие в котором описана вся комната целиком, событие удаление обьекта, событие окончание симмуляции для данного игрока.

События от клиентов попадая на сервер выстраиваются в очередь событий, события попадающие к клиенту применяются сразу же. Заданные типы событий обрабатываются сразу же, а для пользовательских типов событий вызывается соответствующий обработчик, если такой найден. 

Помимо клиента и сервера события могут быть сгенерированы обьектами во время их обновления, для этого в функцию обновления комната передает обьект для передачи сообщений.

События, так же, имеют возможность преобразовываться в json и наоборот, таким образом они передаются по сети. Событие может содержать внутри себя игровой обьект, по этому от обьекта требуется возможность преобразовать себя в набор байт, и быть впоследствии распакованным из набора байт.

\subsection{Графический контекст}

Для взаимодействия с предоставляемыми браузером возможностями отрисовки, написана прослойка, так называемый графический контекст. Графический контекст это специальный обьект, создающийся во время создания клиента. Формат Webassembley позволяет запускать программу на произвольном языке программирования из браузера, однако помимо этого он позволяет обращаться к возможностям браузера используя вызовы Javascript. Соответственно контекст создает внутри себя контекст из canvas, и каждый кадр передает туда свежее изображение. Однако с целью оптимизации, чтобы ликвидировать затраты на вызовы javascript изображение создается целиком на стороне Go, и зачем направляется в javascript. 

Помимо работы с canvas, внутри графического контекста поддержана возможность создавать html элементы в качестве отрисованного результата для обьекта. Это позволяет создавать поля ввода используя средства html вместо создания нового обькта. 

Графический контекст предоставляет интерфейс, позволяющий отрисовать либо произвольную геометрическую форму либо заданную текстуру в заданной точке. Когда все обьекты отрисованы, текстура отправляется в canvas.

Графический контекст требует, чтоб сперва были отрисованы обьекты, которые находятся на заднем плане, а затем обьекты на переднем плане. Эта возможность нужна не всегда, если обьект не поддерживает слои, то он рисуется всегда на самом переднем плане. Для реализации этой возможности, в обьекте Комнате поддержана ещё одна структура данных, массив хештаблиц, каждый массив обозначает слой со своим номером, от самых дальних до самых ближних. В хештаблицах хранятся указатели на обьекты. Это позволяет быстро обходить все обьекты в правильном порядке, а так же быстро добавлять и удалять обьекты.

\subsection{Хранилище данных комнат}

Во втором разделе описывалась проблема хранения комнат, пустую комнату нужно удалять или хранить или продолжать выполнять в зависимости от ситуации. Для этого пользователю передано хранилище данных комнат. Когда комнату покидает последний игрок вызывается либо переданная пользователем функция, либо комната помечается в хранилище как удалённая. Хранилище представляет собой обьект, с хештаблицей, где хранятся активные исполняемые комнаты и подключением к базе данных. По скольку комнаты сами по себе представляют сериализуемый обьект, они спокойно могут храниться в любом возможном хранилище. Go предоставляет абстракцию над базами данных, так что хранилище можно выбирать самостоятельно.

Так же хранилище предоставляет возможность перемещать сущность из комнаты в комнату. При этом в одном режиме сущность просто перемещается, во втором режиме данному подключенному клиенту назначается сущность с
переданным номером в новой комнате.

При создании, хранилище запускает процесс, который раз в некоторое время (раз в несколько минут) сохраняет все активные не динамические комнаты в базу данных, на случай поломок. На данный момент, нет возможности переподключиться к уже запущенной комнате (движок никак не использует куки браузера), однако упавшая комната будет поднята когда к ней кто-то обратится.

\chapter{Реализация игры с помощью движка}

В этом разделе будут описан пример приложения, которое можно создать при помощи данного фреймворка. Приложение носит демонстрационнй характер. Приложение основано на нескольких комнатах. В начале игрок попадает в комнату - лобби. Там игрок видит приветственную фразу, находясь там он дожидается появления в комнате ещё одного игрока. Как только это происходит, начинается собственно игровой процесс. Игроки управляют обьктами - сферами, каждая сфера может отрастить хвост из сфер по-меньше. Цель игры -  добиться того чтобы игрок - противник врезался во второстепенную сферу, при этом не врезаться во второстепенную сферу врага самому. В конце игры игроки попадают в комнату для победы и в комнату для поражения. Затем каждый игрок может переместиться в начальную комнату и начать процесс заново.

Соответственно, в этом концепте существует три наперёд заданные постоянно исполняющиеся, восстанавливающиеся из базы данных при падении комнаты: комната-лобби, комната с победным сообщением, комната с сообщением о проигрыше. Так же - создаются динамические комнаты, они не сохранятся в базу данных при падении.  

\subsection{Создание своих сущностей}

Каждая сущность должна удовлетворять интерфейсу, чтобы быть принятой игрой:
\lstinputlisting[language=Go,
caption=Интерфейс сущности]{element.go}

При помощи этого интерфейса можно создать статическую сущность, она будет находиться всегда в одном месте, она не будет учавствовать в взаимодействиях, ею нельзя будет управлять и она никак не обновляется. Такая сущность полезна для создания статических переменных окружения, например задника или картинки:
\lstinputlisting[language=Go,
caption=Реализация статического окружения]{background.go}

Этот обьект используется в лобби и других статичных комнатах для создания задника при помощи текстуры.

Если пользователь хочет, чтобы реализованные обьекты могли обновляться, учавствовать в коллизии, быть управляемы игроком, то ему следует реализовать следующие методы:
\lstinputlisting[language=Go,
caption=Реализация статического окружения]{interfaces.go}

Не обязательно реализовывать все три, например для лобби используется обьект, реализующий интерфейс игрока, чтобы клиент мог взять управление, но при этом не делающий ничего, игрок просто дожидается появление нового игрока, затем игра переправляет обоих игроков в "игровую" комнату.

Единственный, реализующий все функции обьект это собственно змейка. Змейка состоит из звеньев, каждое звено это окружность, так же она хранит разные дополнительные параметры:
\lstinputlisting[language=Go,
caption=Класс Snake которым управляют игроки]{snake.go}

При отрисовке, змейка по очереди рисует все свои звенья. При получении пользовательского ввода змейка просто возвращает системные значения (они присываваются при помощи коллбеков вызываемых в javascript)
\lstinputlisting[language=Go,
caption=Функции предвижения получения ввода обработки столкновений]{snake-misc.go}

При столкновении змейка использует библиотечную функцию проверки столкновений, и при наличии столкновения погибает.

Наконец, в функции изменения положения змейка либо перемещается, либо отправляет сообщение о проигрыше. 

\lstinputlisting[language=Go,
caption=Функция изменения состояния змейки]{snake-move.go}

В случае смерти, змейка посылает особый эвент $"lose"$ обработчик для которого задается в следующей части. 

Перед использованием обьект необходимо зарегистрировать, это необходимо чтобы правильно распаковывать созданный пользователем обьект при пересылке по сети. 
\lstinputlisting[language=Go,
caption=Функция регистрации типа обьекта]{init.go}


\subsection{Расширение возможностей комнаты}

TODO: Добавить сюда снипеты с кодом особых комнат, функций обработчиков, с пояснениями

\subsection{Сборка и запуск}

TODO: Клиент-сервер, клиент нужно собрать в wasm, при этом нужно чтобы system/js не импортировался сервером (тогда он не соберется, system/js используется только в wasm), про то что игра начинается в index.html, про то что серверу нужно передать конфиг с конфигом базы данных, и т. д.

\chapter{Выводы}

В данной работе был исследован ряд проблем связанных с разработкой real-time web приложений, сложности возникающие при создании сервера, клиента, предпочтительные протоколы и алгоритмы. Сложности обработки столкновений и хранений обьектов. Результатом работы стал движок, который предоставляет пользователю возможность описать обьекты, сконцентрировавшись только на их поведенческой логике. Движок предоставляет сервер, к которому могут подключаться клиенты из браузера. Благодаря системе абстракций "Комната" есть возможность обрабатывать несколько игр параллельно, есть возможность сохранить состояние приложения и продолжить его исполнение. Полученный исходный код выложен на GitHub.

Однако исследование не завершено, главным образом из за возможных оптимизаций существующего кода. Главное необходимое улучшение - добавление возможности переподключения к внезапно остановленой комнате. Так же движку пока что не хватает геометрических возможностей, отсутствую геометрические формы отличниые от сферы и ориентированного прямоугольника. Так же отсутсвует встроенная физическая модель. которая однако требуется в большинстве проектов. Так же нет готовой поддержки анимаций - что требуется ещё чаще. Сюда же можно отнести эффекты постобработки. Всё это может быть постепенно добавлено в существующую кодовую базу без существенных её изменений.


\bibliographystyle{unsrt}
\bibliography{references}

\end{document}